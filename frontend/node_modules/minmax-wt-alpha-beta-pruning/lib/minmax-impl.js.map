{"version":3,"sources":["../src/minmax-impl.js"],"names":["EvaluationAndMove","move","evaluation","minmax","gameState","gameRules","evaluate","plies","alpha","Number","NEGATIVE_INFINITY","beta","POSITIVE_INFINITY","statisticsHook","_minmax","pliesRemaining","maximizing","visitedNode","vForTerminal","terminalStateEval","evaluatedLeafNode","v2","moves","listMoves","NUM_OF_MOVES","length","v","bestMove","i","nextState","nextStateEval","Math","max","Error","pruningIncident","min","isInteger","evalAndMove","exports"],"mappings":"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","file":"minmax-impl.js","sourcesContent":["// @flow\n'use strict';\n\n// The rationale behind using this idiom is described in:\n//     http://stackoverflow.com/a/36628148/274677\n//\n    /* not needed in this project:\n     if (!global._babelPolyfill) // https://github.com/s-panferov/awesome-typescript-loader/issues/121\n         require('babel-polyfill');\n    */\n// The above is important as Babel only transforms syntax (e.g. arrow functions)\n// so you need this in order to support new globals or (in my experience) well-known Symbols, e.g. the following:\n//\n//     console.log(Object[Symbol.hasInstance]);\n//\n// ... will print 'undefined' without the the babel-polyfill being required.\n\n\nimport type {\n    IGameRules, EvaluateFT, MinMaxFT, TMinMaxResult, TMinMaxStatistics\n} from './minmax-interface.js'\n\n\n// This class is only used internally by the algorithm (in the recursive call)\nclass EvaluationAndMove<MoveGTP> {\n    move: ?MoveGTP\n    evaluation: number;\n\n    constructor(move: ?MoveGTP, evaluation: number) {\n        this.move = move;\n        this.evaluation = evaluation;\n    }\n\n}\n\nfunction minmax <GameStateGTP, MoveGTP>\n    (gameState           : GameStateGTP\n     , gameRules         : IGameRules<GameStateGTP, MoveGTP>\n     , evaluate          : EvaluateFT<GameStateGTP>\n     , plies             : number\n     , alpha             : number = Number.NEGATIVE_INFINITY\n     , beta              : number = Number.POSITIVE_INFINITY \n     , statisticsHook    : ?TMinMaxStatistics<GameStateGTP>\n    )\n    : TMinMaxResult<MoveGTP> {\n\n    \n        function _minmax(gameState           : GameStateGTP\n                              , pliesRemaining    : number\n                              , alpha             : number\n                              , beta              : number                              \n                              , maximizing        : boolean\n                             ): EvaluationAndMove<MoveGTP> {\n                                 if (statisticsHook!=null) statisticsHook.visitedNode(gameState);\n                                 const vForTerminal: ?number = gameRules.terminalStateEval(gameState);\n                                 if ( (vForTerminal!=null) || (pliesRemaining===0)) {\n                                     if (statisticsHook!=null) statisticsHook.evaluatedLeafNode(gameState);\n                                     const v2 : number = (vForTerminal!=null?vForTerminal:evaluate(gameState));\n                                     return new EvaluationAndMove(null, v2*(maximizing?1:-1));\n                                 } else {\n                                     // construct the children and evaluate them\n                                     const moves: Array<MoveGTP> = gameRules.listMoves(gameState);\n                                     const NUM_OF_MOVES: number = moves.length;\n                                     if (NUM_OF_MOVES<=0)\n                                         throw `weird number of moves (${NUM_OF_MOVES}) in non-terminal state`\n                                     // one can add cleverness and squeeze the two branches into one at the expense of readability \n                                     if (maximizing) {\n                                         var v       : number   = Number.NEGATIVE_INFINITY;\n                                         var bestMove: ?MoveGTP = null;\n                                         for (let i = 0; i < NUM_OF_MOVES ; i++) {\n                                             const nextState: (GameStateGTP) = gameRules.nextState(gameState, moves[i]);\n                                             const nextStateEval: ?EvaluationAndMove<MoveGTP> = _minmax(nextState, pliesRemaining-1, Math.max(v, alpha), beta, !maximizing);\n                                             if (nextStateEval!=null) {\n                                                 if (nextStateEval.evaluation > v) {\n                                                     if (nextStateEval.evaluation===Number.POSITIVE_INFINITY) // no need to look any further\n                                                         return new EvaluationAndMove(moves[i], nextStateEval.evaluation); \n                                                     v        = nextStateEval.evaluation\n                                                     bestMove = moves[i];\n                                                 }\n                                             } else throw new Error('impossible at this point');\n                                             if ((v>=beta) && (i!==NUM_OF_MOVES-1)) { /* sse-1512513725: in the various resources on the algorithm I\n                                                                                         always see this as (v>beta) but I am confident there is no\n                                                                                         reason not to use \">=\" instead as this is better (it\n                                                                                         increases the likelihood of pruning). Also, if this is\n                                                                                         the last child, we don't consider it a true pruning incident\n                                                                                         for statistical purposes (the logic remains effectively the\n                                                                                         same as for the last child we are going to break out of the\n                                                                                         loop anyways */\n                                                 if (statisticsHook!=null) statisticsHook.pruningIncident(gameState, true, v, beta, i);\n                                                 break;\n                                             }\n                                         }\n                                         if (! ((v===Number.NEGATIVE_INFINITY) || (bestMove!=null) ))\n                                             throw `maximizing node, v is ${v==null?'null':v}, bestMove is: ${bestMove==null?'null':bestMove} - this makes no sense`;\n                                         return new EvaluationAndMove(bestMove!==null?bestMove:moves[0], v); // if all moves are equally bad, return the first one\n                                     } else {\n                                         var v       : number   = Number.POSITIVE_INFINITY;\n                                         var bestMove: ?MoveGTP = null;\n                                         for (let i = 0; i < NUM_OF_MOVES ; i++) {\n                                             const nextState: (GameStateGTP) = gameRules.nextState(gameState, moves[i]);\n                                             const nextStateEval: ?EvaluationAndMove<MoveGTP> = _minmax(nextState, pliesRemaining-1, alpha, Math.min(v,beta), !maximizing);\n                                             if (nextStateEval!=null) {\n                                                 if (nextStateEval.evaluation===Number.NEGATIVE_INFINITY) // no need to look any further\n                                                     return new EvaluationAndMove(moves[i], nextStateEval.evaluation);                                                  \n                                                 if (nextStateEval.evaluation<v) {\n                                                     v        = nextStateEval.evaluation;\n                                                     bestMove = moves[i];\n                                                 }\n                                             } else throw new Error('impossible at this point');\n                                             if ((v<=alpha) && (i!==NUM_OF_MOVES-1)) { // see sse-1512513725 (mutatis mutandis)\n                                                 if (statisticsHook!=null) statisticsHook.pruningIncident(gameState, false, v, alpha, i);\n                                                 break;\n                                             }\n                                         }\n                                         if (! ((v===Number.POSITIVE_INFINITY) || (bestMove!=null)))\n                                             throw `minimizing node, v is ${v==null?'null':v}, bestMove is: ${bestMove==null?'null':bestMove} - this makes no sense`;\n                                         return new EvaluationAndMove(bestMove!==null?bestMove:moves[0], v); // if all moves are equally bad, return the first one\n                                     }\n                                 }\n                             }\n        const v: ?number = gameRules.terminalStateEval(gameState);\n        if (v!=null)\n            return {\n                bestMove: null,\n                evaluation: v\n            };\n        else {\n            if (! (Number.isInteger(plies) && (plies>=0) ))\n                throw `illegal plies for minmax: ${plies}`;\n            const evalAndMove :EvaluationAndMove<MoveGTP> = _minmax(gameState, plies, alpha, beta, true); // in the min-max algorithm the player who is to make the move is the maximizing player\n            if (! ( (plies===0) || (evalAndMove.move!=null) ))\n                throw `this is not a terminal state, plies were not 0 (they were ${plies}) and yet, no move was found, this makes no sense`;\n            return {\n                bestMove  : evalAndMove.move,\n                evaluation: evalAndMove.evaluation\n            };\n\n        }\n    }\n\n(minmax: MinMaxFT<mixed, mixed>)\n\nexports.minmax = minmax;\n\n"]}