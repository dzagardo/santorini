{"version":3,"sources":["../src/minmax-interface.js"],"names":[],"mappings":"AACA;;AAEA;AACA;AACA;AACI;;;;AAIJ;AACA;AACA;AACA;AACA;AACA;;;AAIA","file":"minmax-interface.js","sourcesContent":["// @flow\n'use strict';\n\n// The rationale behind using this idiom is described in:\n//     http://stackoverflow.com/a/36628148/274677\n//\n    /* not needed in this project:\n        if (!global._babelPolyfill) // https://github.com/s-panferov/awesome-typescript-loader/issues/121\n        require('babel-polyfill');\n    */\n// The above is important as Babel only transforms syntax (e.g. arrow functions)\n// so you need this in order to support new globals or (in my experience) well-known Symbols, e.g. the following:\n//\n//     console.log(Object[Symbol.hasInstance]);\n//\n// ... will print 'undefined' without the the babel-polyfill being required.\n\n\n\n/*\nGuide to naming conventions used\n-------------------------------\nGTP            : Generic Type Parameter\n{T/I}SomeType  : Interface or Type (respectively) for class or object structural (not nominal) typing\nSomeFunctionFT : Function Type\n*/\n\n\nexport type ListMovesFT<GameStateGTP, MoveGTP> = (GameStateGTP)=>Array<MoveGTP>\nexport type NextStateFT<GameStateGTP, MoveGTP> = (GameStateGTP, MoveGTP)=>GameStateGTP\n\nexport type IGameRules<GameStateGTP, MoveGTP> = {|\n    /* The framework will *never* call the listMoveser on a terminal state so you don't have to handle that state.\n       If you don't trust, me simply return [] on a terminal state even though you can just as well throw an\n       exception in that case as execution will never reach that path.\n     */\n    listMoves                                          : ListMovesFT<GameStateGTP, MoveGTP>,\n    nextState                                          : NextStateFT<GameStateGTP, MoveGTP>,\n    terminalStateEval (gs: GameStateGTP)               : ?number\n|}\n\n\n\n\n/* The evaluate function will ***always*** evaluate from the perspective of the moving player\n   (we assume that information on which player is moving is embedded in the GameStateGTP)\n   positive infinity means  WIN  or hugely    favourable situation for the moving player\n   negative --------------- LOSS ---------- unfavourable ------------------------------\n\n   Note that in the general case it is possible for a game's terminal state to have\n   an evaluation that's neither positive nor negative infinity (e.g. if the game allows\n   draws or some other graded outcome).\n\n   The evaluate function has no concept of \"maximizing\" or \"minimizing\" player. This is an artifact\n   of the minmax algorithm. The evaluate function simply reports from the perspective of the moving\n   player and the minmax implementation (that constructs the game tree) takes account of who the\n   maximizing or minimizing player is and proceeds accordingly. I.e., it effectively multiplies the\n   return value of the evaluate function by +1 or -1 respectively.\n */\n\nexport type EvaluateFT <GameStateGTP> = (gs: GameStateGTP) => number;\n\nexport type TMinMaxResult<MoveGTP> =\n    {|\n        bestMove  : ?MoveGTP,\n        evaluation: number\n    |}\n\n\nexport type TMinMaxStatistics<GameStateGTP> =\n    {\n     visitedNode       (n: GameStateGTP): void,\n     evaluatedLeafNode (n: GameStateGTP): void,\n     pruningIncident   (n: GameStateGTP, aboveBetaOrBelowAlpha: boolean, v: number, alphaOrBetaValue: number, index: number): void\n    };\n\n/* The minmax function type (MinMaxFT) returns both the best move and the evaluation of the root\n   node. It assumes that the moving player at the root is also the maximizing player.\n   \n   Another way to think of the alpha and beta values is the following:\n   * alpha: execute the algorithm (with the moving player being the maximizing player) assuming that the\n            opponnent will be happy with any value less than alpha and will not try to minimize any further\n            once he finds a move that yields an evaluation less than alpha. Default initial value: negative infinity.\n     beta:  execute the algorithm and (while on a maximizing node) don't bother searching for anything better than\n            beta. Default initial value: positive infinity.\n   It should NOT be assumed that the algorithm will return a value in the [alpha, beta] range. In fact it is quite\n   possible that you invoke the algorithm with alpha >= beta (e.g. see test file minmax-test-pseudo-games.js and the\n   pseudoGameLogic7 test game). Though I don't know whether that makes any sense.\n */\nexport type MinMaxFT<GameStateGTP, MoveGTP> =\n    (gameState   : GameStateGTP\n     , gameRules : IGameRules<GameStateGTP, MoveGTP>\n     , evaluate: EvaluateFT<GameStateGTP>\n     , plies: number\n     , alpha?: number\n     , beta?:  number\n     , statisticsHook?: TMinMaxStatistics<GameStateGTP>\n    ) => TMinMaxResult<MoveGTP>;\n\n\n\n"]}