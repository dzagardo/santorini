{"ast":null,"code":"'use strict'; // The rationale behind using this idiom is described in:\n//     http://stackoverflow.com/a/36628148/274677\n//\n\n/* not needed in this project:\n if (!global._babelPolyfill) // https://github.com/s-panferov/awesome-typescript-loader/issues/121\n     require('babel-polyfill');\n*/\n// The above is important as Babel only transforms syntax (e.g. arrow functions)\n// so you need this in order to support new globals or (in my experience) well-known Symbols, e.g. the following:\n//\n//     console.log(Object[Symbol.hasInstance]);\n//\n// ... will print 'undefined' without the the babel-polyfill being required.\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // This class is only used internally by the algorithm (in the recursive call)\n\n\nvar EvaluationAndMove = function EvaluationAndMove(move, evaluation) {\n  _classCallCheck(this, EvaluationAndMove);\n\n  this.move = move;\n  this.evaluation = evaluation;\n};\n\nfunction minmax(gameState, gameRules, evaluate, plies) {\n  var alpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;\n  var beta = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Number.POSITIVE_INFINITY;\n  var statisticsHook = arguments[6];\n\n  function _minmax(gameState, pliesRemaining, alpha, beta, maximizing) {\n    if (statisticsHook != null) statisticsHook.visitedNode(gameState);\n    var vForTerminal = gameRules.terminalStateEval(gameState);\n\n    if (vForTerminal != null || pliesRemaining === 0) {\n      if (statisticsHook != null) statisticsHook.evaluatedLeafNode(gameState);\n      var v2 = vForTerminal != null ? vForTerminal : evaluate(gameState);\n      return new EvaluationAndMove(null, v2 * (maximizing ? 1 : -1));\n    } else {\n      // construct the children and evaluate them\n      var moves = gameRules.listMoves(gameState);\n      var NUM_OF_MOVES = moves.length;\n      if (NUM_OF_MOVES <= 0) throw 'weird number of moves (' + NUM_OF_MOVES + ') in non-terminal state'; // one can add cleverness and squeeze the two branches into one at the expense of readability \n\n      if (maximizing) {\n        var v = Number.NEGATIVE_INFINITY;\n        var bestMove = null;\n\n        for (var i = 0; i < NUM_OF_MOVES; i++) {\n          var nextState = gameRules.nextState(gameState, moves[i]);\n\n          var nextStateEval = _minmax(nextState, pliesRemaining - 1, Math.max(v, alpha), beta, !maximizing);\n\n          if (nextStateEval != null) {\n            if (nextStateEval.evaluation > v) {\n              if (nextStateEval.evaluation === Number.POSITIVE_INFINITY) // no need to look any further\n                return new EvaluationAndMove(moves[i], nextStateEval.evaluation);\n              v = nextStateEval.evaluation;\n              bestMove = moves[i];\n            }\n          } else throw new Error('impossible at this point');\n\n          if (v >= beta && i !== NUM_OF_MOVES - 1) {\n            /* sse-1512513725: in the various resources on the algorithm I\n               always see this as (v>beta) but I am confident there is no\n               reason not to use \">=\" instead as this is better (it\n               increases the likelihood of pruning). Also, if this is\n               the last child, we don't consider it a true pruning incident\n               for statistical purposes (the logic remains effectively the\n               same as for the last child we are going to break out of the\n               loop anyways */\n            if (statisticsHook != null) statisticsHook.pruningIncident(gameState, true, v, beta, i);\n            break;\n          }\n        }\n\n        if (!(v === Number.NEGATIVE_INFINITY || bestMove != null)) throw 'maximizing node, v is ' + (v == null ? 'null' : v) + ', bestMove is: ' + (bestMove == null ? 'null' : bestMove) + ' - this makes no sense';\n        return new EvaluationAndMove(bestMove !== null ? bestMove : moves[0], v); // if all moves are equally bad, return the first one\n      } else {\n        var v = Number.POSITIVE_INFINITY;\n        var bestMove = null;\n\n        for (var _i = 0; _i < NUM_OF_MOVES; _i++) {\n          var _nextState = gameRules.nextState(gameState, moves[_i]);\n\n          var _nextStateEval = _minmax(_nextState, pliesRemaining - 1, alpha, Math.min(v, beta), !maximizing);\n\n          if (_nextStateEval != null) {\n            if (_nextStateEval.evaluation === Number.NEGATIVE_INFINITY) // no need to look any further\n              return new EvaluationAndMove(moves[_i], _nextStateEval.evaluation);\n\n            if (_nextStateEval.evaluation < v) {\n              v = _nextStateEval.evaluation;\n              bestMove = moves[_i];\n            }\n          } else throw new Error('impossible at this point');\n\n          if (v <= alpha && _i !== NUM_OF_MOVES - 1) {\n            // see sse-1512513725 (mutatis mutandis)\n            if (statisticsHook != null) statisticsHook.pruningIncident(gameState, false, v, alpha, _i);\n            break;\n          }\n        }\n\n        if (!(v === Number.POSITIVE_INFINITY || bestMove != null)) throw 'minimizing node, v is ' + (v == null ? 'null' : v) + ', bestMove is: ' + (bestMove == null ? 'null' : bestMove) + ' - this makes no sense';\n        return new EvaluationAndMove(bestMove !== null ? bestMove : moves[0], v); // if all moves are equally bad, return the first one\n      }\n    }\n  }\n\n  var v = gameRules.terminalStateEval(gameState);\n  if (v != null) return {\n    bestMove: null,\n    evaluation: v\n  };else {\n    if (!(Number.isInteger(plies) && plies >= 0)) throw 'illegal plies for minmax: ' + plies;\n\n    var evalAndMove = _minmax(gameState, plies, alpha, beta, true); // in the min-max algorithm the player who is to make the move is the maximizing player\n\n\n    if (!(plies === 0 || evalAndMove.move != null)) throw 'this is not a terminal state, plies were not 0 (they were ' + plies + ') and yet, no move was found, this makes no sense';\n    return {\n      bestMove: evalAndMove.move,\n      evaluation: evalAndMove.evaluation\n    };\n  }\n}\n\nminmax;\nexports.minmax = minmax;","map":{"version":3,"sources":["/Users/davidzagardo/Dropbox/My Mac (Davids-MacBook-Pro.local)/Desktop/INTELLIJ/17514hw3/frontend/node_modules/minmax-wt-alpha-beta-pruning/src/minmax-impl.js"],"names":["EvaluationAndMove","alpha","Number","NEGATIVE_INFINITY","beta","POSITIVE_INFINITY","statisticsHook","vForTerminal","gameRules","pliesRemaining","v2","evaluate","maximizing","moves","NUM_OF_MOVES","v","bestMove","i","nextState","nextStateEval","_minmax","Math","evaluation","plies","evalAndMove","minmax","exports"],"mappings":"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","sourcesContent":["// @flow\n'use strict';\n\n// The rationale behind using this idiom is described in:\n//     http://stackoverflow.com/a/36628148/274677\n//\n    /* not needed in this project:\n     if (!global._babelPolyfill) // https://github.com/s-panferov/awesome-typescript-loader/issues/121\n         require('babel-polyfill');\n    */\n// The above is important as Babel only transforms syntax (e.g. arrow functions)\n// so you need this in order to support new globals or (in my experience) well-known Symbols, e.g. the following:\n//\n//     console.log(Object[Symbol.hasInstance]);\n//\n// ... will print 'undefined' without the the babel-polyfill being required.\n\n\nimport type {\n    IGameRules, EvaluateFT, MinMaxFT, TMinMaxResult, TMinMaxStatistics\n} from './minmax-interface.js'\n\n\n// This class is only used internally by the algorithm (in the recursive call)\nclass EvaluationAndMove<MoveGTP> {\n    move: ?MoveGTP\n    evaluation: number;\n\n    constructor(move: ?MoveGTP, evaluation: number) {\n        this.move = move;\n        this.evaluation = evaluation;\n    }\n\n}\n\nfunction minmax <GameStateGTP, MoveGTP>\n    (gameState           : GameStateGTP\n     , gameRules         : IGameRules<GameStateGTP, MoveGTP>\n     , evaluate          : EvaluateFT<GameStateGTP>\n     , plies             : number\n     , alpha             : number = Number.NEGATIVE_INFINITY\n     , beta              : number = Number.POSITIVE_INFINITY \n     , statisticsHook    : ?TMinMaxStatistics<GameStateGTP>\n    )\n    : TMinMaxResult<MoveGTP> {\n\n    \n        function _minmax(gameState           : GameStateGTP\n                              , pliesRemaining    : number\n                              , alpha             : number\n                              , beta              : number                              \n                              , maximizing        : boolean\n                             ): EvaluationAndMove<MoveGTP> {\n                                 if (statisticsHook!=null) statisticsHook.visitedNode(gameState);\n                                 const vForTerminal: ?number = gameRules.terminalStateEval(gameState);\n                                 if ( (vForTerminal!=null) || (pliesRemaining===0)) {\n                                     if (statisticsHook!=null) statisticsHook.evaluatedLeafNode(gameState);\n                                     const v2 : number = (vForTerminal!=null?vForTerminal:evaluate(gameState));\n                                     return new EvaluationAndMove(null, v2*(maximizing?1:-1));\n                                 } else {\n                                     // construct the children and evaluate them\n                                     const moves: Array<MoveGTP> = gameRules.listMoves(gameState);\n                                     const NUM_OF_MOVES: number = moves.length;\n                                     if (NUM_OF_MOVES<=0)\n                                         throw `weird number of moves (${NUM_OF_MOVES}) in non-terminal state`\n                                     // one can add cleverness and squeeze the two branches into one at the expense of readability \n                                     if (maximizing) {\n                                         var v       : number   = Number.NEGATIVE_INFINITY;\n                                         var bestMove: ?MoveGTP = null;\n                                         for (let i = 0; i < NUM_OF_MOVES ; i++) {\n                                             const nextState: (GameStateGTP) = gameRules.nextState(gameState, moves[i]);\n                                             const nextStateEval: ?EvaluationAndMove<MoveGTP> = _minmax(nextState, pliesRemaining-1, Math.max(v, alpha), beta, !maximizing);\n                                             if (nextStateEval!=null) {\n                                                 if (nextStateEval.evaluation > v) {\n                                                     if (nextStateEval.evaluation===Number.POSITIVE_INFINITY) // no need to look any further\n                                                         return new EvaluationAndMove(moves[i], nextStateEval.evaluation); \n                                                     v        = nextStateEval.evaluation\n                                                     bestMove = moves[i];\n                                                 }\n                                             } else throw new Error('impossible at this point');\n                                             if ((v>=beta) && (i!==NUM_OF_MOVES-1)) { /* sse-1512513725: in the various resources on the algorithm I\n                                                                                         always see this as (v>beta) but I am confident there is no\n                                                                                         reason not to use \">=\" instead as this is better (it\n                                                                                         increases the likelihood of pruning). Also, if this is\n                                                                                         the last child, we don't consider it a true pruning incident\n                                                                                         for statistical purposes (the logic remains effectively the\n                                                                                         same as for the last child we are going to break out of the\n                                                                                         loop anyways */\n                                                 if (statisticsHook!=null) statisticsHook.pruningIncident(gameState, true, v, beta, i);\n                                                 break;\n                                             }\n                                         }\n                                         if (! ((v===Number.NEGATIVE_INFINITY) || (bestMove!=null) ))\n                                             throw `maximizing node, v is ${v==null?'null':v}, bestMove is: ${bestMove==null?'null':bestMove} - this makes no sense`;\n                                         return new EvaluationAndMove(bestMove!==null?bestMove:moves[0], v); // if all moves are equally bad, return the first one\n                                     } else {\n                                         var v       : number   = Number.POSITIVE_INFINITY;\n                                         var bestMove: ?MoveGTP = null;\n                                         for (let i = 0; i < NUM_OF_MOVES ; i++) {\n                                             const nextState: (GameStateGTP) = gameRules.nextState(gameState, moves[i]);\n                                             const nextStateEval: ?EvaluationAndMove<MoveGTP> = _minmax(nextState, pliesRemaining-1, alpha, Math.min(v,beta), !maximizing);\n                                             if (nextStateEval!=null) {\n                                                 if (nextStateEval.evaluation===Number.NEGATIVE_INFINITY) // no need to look any further\n                                                     return new EvaluationAndMove(moves[i], nextStateEval.evaluation);                                                  \n                                                 if (nextStateEval.evaluation<v) {\n                                                     v        = nextStateEval.evaluation;\n                                                     bestMove = moves[i];\n                                                 }\n                                             } else throw new Error('impossible at this point');\n                                             if ((v<=alpha) && (i!==NUM_OF_MOVES-1)) { // see sse-1512513725 (mutatis mutandis)\n                                                 if (statisticsHook!=null) statisticsHook.pruningIncident(gameState, false, v, alpha, i);\n                                                 break;\n                                             }\n                                         }\n                                         if (! ((v===Number.POSITIVE_INFINITY) || (bestMove!=null)))\n                                             throw `minimizing node, v is ${v==null?'null':v}, bestMove is: ${bestMove==null?'null':bestMove} - this makes no sense`;\n                                         return new EvaluationAndMove(bestMove!==null?bestMove:moves[0], v); // if all moves are equally bad, return the first one\n                                     }\n                                 }\n                             }\n        const v: ?number = gameRules.terminalStateEval(gameState);\n        if (v!=null)\n            return {\n                bestMove: null,\n                evaluation: v\n            };\n        else {\n            if (! (Number.isInteger(plies) && (plies>=0) ))\n                throw `illegal plies for minmax: ${plies}`;\n            const evalAndMove :EvaluationAndMove<MoveGTP> = _minmax(gameState, plies, alpha, beta, true); // in the min-max algorithm the player who is to make the move is the maximizing player\n            if (! ( (plies===0) || (evalAndMove.move!=null) ))\n                throw `this is not a terminal state, plies were not 0 (they were ${plies}) and yet, no move was found, this makes no sense`;\n            return {\n                bestMove  : evalAndMove.move,\n                evaluation: evalAndMove.evaluation\n            };\n\n        }\n    }\n\n(minmax: MinMaxFT<mixed, mixed>)\n\nexports.minmax = minmax;\n\n"]},"metadata":{},"sourceType":"script"}